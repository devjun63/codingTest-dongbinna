#codingTest-dongbinna
(공부 내용 정리)
<br>출처 : 이것이 취업을 위한 코딩테스트다 with 파이썬

## 계수 정렬


### 계수정렬의 특징

---

**계수 정렬(*Count Sort*)** 알고리즘은 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
데이터의 크기 범위가 제한 되어 정수 형태로 표현할 수 있을 때, 데이터의 개수가 N,
데이터 중 최댓값이 K일 때, 계수 정렬은 최악의 경우에도 수행 시간 O(N+K)를 보장한다.
일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.
이러한 특징은, 계수 정렬을 이용할 때 '모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언'해야 하기 때문이다.
또한 계수 정렬은 앞서 다루었던 3가지 정렬 알고리즘 처럼 비교 기반 정렬 알고리즘이 아니다.

---

```python
6-6.py 계수 정렬 소스코드
# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

#모든 범위르 ㄹ포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가

for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수 만큼 인덱스 출력


출력 결과 : 0 0 1 1 2 2 3 4 5 5 6 7 8 9 9 
```

#### 계수 정렬의 시간 복잡도

---

 모든 데이터가 양의 정수인 상황에서 데이터의 개수를 N, 데이터 중 최대값의 크기를 K라고 할 때,
 계수 정렬의 시간 복잡도는 O(N+K)이다.
 이는 앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킬 뿐만 아니라,
 추후에 리스트의 각 인덱스에 해당하는 값들을 확인할 때 데이터 중 최댓값의 크기만큼 반복을 수행하기 때문이다.
 따라서 데이터의 범위만 항정되어 있다면 효과적으로 사용할 수 있고 항상 빠르게 동작한다.
 사실 현존하는 정렬 알고리즘 중에서 기수 정렬(Radix Sort)와 더불어 가장 빠르다고 볼 수 있다.
 
 --- 
#### 계수 정렬의 공간 복잡도

계수 정렬은 때에 따라서 심각한 비 효율성을 초래할 수 있다.
예를 들어 데이터가 0과 999,999 단 2개만 존재한다고 가정하면
이 범위를 담기 위해서 100만 개의 크기의 리스트를 선언해야 한다.
따라서 항상 사용할 수 있는 정렬 알고리즘은 아니고, 
동일한 값을 가지는 데이터가 여러 개 등장할 때 적합하다.
다시 말해 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록
유리하며 항상 사용할 수는 없다.
하지만 조건만 만족한다면 계수 정렬은 정렬해야 하는 데이터의 개수가 매우 많을 때에도 효과적으로 ㅏ용할 수 있다.
다만 일반적인 코딩 테스트의 시스템 환경에서 메모리 공간상의 제약과 입출력 시간 문제로 인하여 입력되는 데이터의 개수를
1,000만 개 이상으로 설정할 수는 없는 경우가 많기 때문에, 정렬 문제에서의 데이터 개수는
1,000만 개 미만으로 출제될 것이다.<br>
계수 정렬의 공간 복잡도는 O(N+K)이다.
